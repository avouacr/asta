---
title: "module5"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{module5}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(asta)
library(datasets)
library(lubridate)
library(ggplot2)
library(dygraphs)
```

# Analyse de la série

## Visualisation

Dans cette onglet, il faut d'abord choisir une série parmi celles proposées dans le menu déroulant : 
- Airpassengers (package datasets)
- Taux d'occupation dans l'hotellerie
- Nombre de visiteurs d'un musée


```{r}

#Fonction qui transforme une ts en dataframe
ts_to_dt <- function(serie_ts,date_debut,periode,taille){
  
  data.frame(
  date=seq(date_debut, by = periode, length.out = taille),
  as.data.frame(serie_ts)
  )
}


#Exemple
airpass_dt <- ts_to_dt(airpass,
         date_debut = my("01/1949"),
         periode = "month",
         taille = 144)

```

Création d'une fonction qui récupère le nom de la série au format caractère pour l'afficher au format dygraph.



```{r}

#Représentation graphique avec PLOT
plot_ts <- function(serie_ts){
  plot.ts(eval(parse(text = serie_ts)))
}
plot_ts("airpass")


#Représentation graphique avec DYGRAPHS
# dygraph_ts <- function(serie_ts){
#   dygraph(serie_ts)
# }

dygraph_ts(airpass)
dygraph_ts(hotel)
# hotel_cut <- window(hotel,start = c(2011,1),end = c(2019,12))
# dygraph_ts(hotel_cut)

#dygraph_ts(visiteurs) Celle-là ne fonctionne pas

#Représentation graphique avec GGPLOT
plot_dt <- function(dt){
  ggplot(dt)+
    aes(x = date,y=x) +
    geom_line()
}
#Exemple
plot_dt(airpass_dt)

```

## Etude de la saisonnalité

```{r}
# graph_month <-function(serie_ts){
#   monthplot(serie_ts,cex.main = 1,ylab = "",col='dodgerblue',col.base = 'indianred',lwd.base = 3)
# }
graph_month(airpass)
graph_month(hotel)
graph_month(visiteurs)
```


# Desaisonnalisation

## Avec la regression linéaire

Dans le menu paramètres, il faut choisir une série. Cocher la case pour prendre ou pas le logarithme (en fonction de l'allure de la courbe). 

```{r}

#fonction qui prend une série temporelle en entrée et qui renvoie 
#le modèle de regression linéaire en sortie
# cvs_reg_model <- function(x){
#   
#   n <- length(x) #Nombre d'observations de la série temporelle
#   t <- 1:n #création d'une série
#   f <- frequency(x) #nombre de périodes par saison
#   ns <- n/f #Nombre de saisons (Valeur entière)
#   for (i in 1:f) {
#     su <- rep(0,times=f)
#     su[i] <- 1
#     s <- rep(su,times=ns)
#     assign(paste("s",i,sep=""),s)
#     rm(s,su)
#   } #création des variables explicatives s1 jusqu'à sf
#   a <- paste0("x~t-1+",paste0("s",1:f,collapse = "+"))
#   reg <- lm(as.formula(a)) #modèle de regression
#   reg
#   
# }

#Récupération de la série grace au menu déroulant
ts1 <- eval(parse(text="airpass"))
ts2 <- eval(parse(text="hotel"))
ts3 <- eval(parse(text="visiteurs"))

#Exemples pour la fonction
reg_airpass <- cvs_reg_model(log(airpass))
summary(reg_airpass)

reg_visiteurs <- cvs_reg_model(visiteurs)
summary(reg_visiteurs)

#Version modifiée de la fréquentation hôtelière

reg_hotel <- cvs_reg_model(hotel)
summary(reg_hotel)

#x est une série temporelle avec saisonnalité (avec frequency)
# cvs_reg_desais <- function(x){
#   n <- length(x) #Nombre d'observations de la série temporelle
#   t <- 1:n
#   f <- frequency(x) #saisonnalité
#   ns <- n/f #Nombre de saisons (Valeur entière)
#   for (i in 1:f) {
#     su <- rep(0,times=f)
#     su[i] <- 1
#     s <- rep(su,times=ns)
#     assign(paste("s",i,sep=""),s)
#     rm(s,su)
#   } #création des variables explicatives s1 jusqu'à sf
#   a <- paste0("x~t-1+",paste0("s",1:f,collapse = "+"))
#   reg <- lm(as.formula(a)) #modèle de regression
#   #récupération des coefficients issus de la regression et centrage
#   a <- mean(reg$coefficients[2:(f+1)])
#   b <- reg$coefficients[1]
#   c <- reg$coefficients[2:(f+1)]-a
#   
#   #on centre les coefficients pour respecter les ordres de grandeur
#   d <- paste0("c[",1:f,"]")
#   e <- paste0("s",1:f)
#   f <- paste0(d,"*",e,collapse = "+")
#   
#   #création d'un vecteur avec les coeffs
#   #de desaisonnalisation
#   g <- eval(parse(text = f))
#   x - g
# }

#Exemple avec airpass 
x <- airpass
y <- log(airpass)
# on désaisonnalise la série passée en logarithme puis on repasse à l'exponentiel
ycvs <- cvs_reg_desais(y)
xcvs <- exp(ycvs)


#1 - test sur la série Airpass

#Fonction qui prend la serie desaisonnalisée et la série brute, et qui renvoie 
# les deux séries sur un même graphique
# dygraph_reg_cvs <- function(x,x_cvs){
#   x_brut_cvs <- cbind(x,x_cvs)
#   dygraph(x_brut_cvs)
# } 



dygraph_reg_cvs(x,xcvs)


#Test sur la fréquentation hôtelière (on ne garde que la partie qui fonctionne bien)
x <- hotel
xcvs <- cvs_reg_desais(x)
dygraph_reg_cvs(x,xcvs)

```

## Avec les moyennes mobiles

```{r}

#Dans l'application, il faut choisir une série 
#puis choisir un type de modèle
cvs_mm_graph <- function(x,...){
  decomp.x <- decompose(x,...)
  plot(decomp.x)
}

#Décomposition de airpass
cvs_mm_graph(airpass,type="multiplicative")

#décomposition de visiteurs
cvs_mm_graph(visiteurs,type="additive")

#Décomposition de fréquentation hôtelière
cvs_mm_graph(hotel,type="additive")
decompose(hotel)

cvs_mm_desais <- function(x,...){
  decomp.x <- decompose(x,...)
  if (decomp.x$type == "multiplicative"){
    x/decomp.x$seasonal
  } else {
      x - decomp.x$seasonal
  }
}

# airpasscvs_mm <- cvs_mm_desais(airpass,type="multiplicative")
# airpasscvs_reg <- exp(cvs_reg_desais(log(airpass)))
# dygraph(cbind(airpass,airpasscvs_mm,airpasscvs_reg))
# 
# 
# m2_12=function(x){
# y=(1/12)*filter(x,c(0.5,rep(1,times=11),0.5))
# return(y)
# }
# 
# x <- hotel
# y <- m2_12(x)
# dygraph(cbind(x,y))
# 
# z <- x - y
# m3=function(x){
# y=(1/3)*filter(x,rep(1,times=3))
# return(y)
# }
# 
# s1 <- m3(m3(z))
# S <- s1 - m2_12(s1)
# dygraph(m2_12(s1))
# 
# dygraph(cbind(x,y,s1))
# 
# bruit <- ts(rnorm(108,sd = 9),frequency = 12)
# bruit_lissee <- m3(m3(bruit))
# 
# dygraph(cbind(bruit,bruit_lissee))

```

